<html>
<head>
  <title>TensorflowJS Segmentation Classification</title>
</head>
<body>
  <h1>TensorflowJS ImageSegmentationClassification</h1>

  <!-- Load the TensorflowJS library -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>

  <!-- Load the model from the local folder -->
  <script>
    const modelUrl = './diceDetectionModeltfjs_reduced/model.json';
    let model;

    async function loadModel() {
      model = await tf.loadLayersModel(modelUrl);
    }

    loadModel();
    
    <!-- Function that loads the image and returns the split images -->
    async function getSplitImages(image_path) {
      //Load the image
      var image = new Image();
      image.src = image_path;
      image.onload = function() {
        //Resize the image to 256x256
        var canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        var ctx = canvas.getContext('2d');
        ctx.drawImage(image, 0, 0, 256, 256);
        //Convert the image to a numpy array
        var imageData = ctx.getImageData(0, 0, 256, 256);
        var data = imageData.data;
        var image = [];
        for (var i = 0; i < data.length; i += 4) {
          image.push(data[i]/255.0);
          image.push(data[i+1]/255.0);
          image.push(data[i+2]/255.0);
        }
        //Reshape the image to fit the model
        image = tf.tensor(image, [1,256,256,3]);
        //Get the predictions
        var predictions = model.predict(image);
        //Process the predictions
        var bboxes = processPredictions(predictions, [image_path], image_grid);
        //Split the image
        var images = splitImage(image_path, bboxes);
        //Display the images
        for (var i = 0; i < images.length; i++) {
          var img = document.createElement('img');
          img.src = images[i];
          document.body.appendChild(img);
        }
      }
    }
    
    <!-- Function that takes an image and a list of bounding boxes and splits the image into multiple images based on the bounding boxes -->
    function splitImage(image_path, bboxes) {
      var image = new Image();
      image.src = image_path;
      image.onload = function() {
        var ratio = image.height / 256;
        var images = [];
        for (var i = 0; i < bboxes[image_path].length; i++) {
          var box = bboxes[image_path][i];
          var left = Math.max(Math.round((box[0]-8)*ratio),0);
          var top = Math.max(Math.round((box[1]-8)*ratio),0);
          var width = Math.min(Math.round((box[2]+16)*ratio),image.width);
          var height = Math.min(Math.round((box[3]+16)*ratio),image.height);
          //Crop the image
          var crop_canvas = document.createElement('canvas');
          crop_canvas.width = width;
          crop_canvas.height = height;
          var crop_ctx = crop_canvas.getContext('2d');
          crop_ctx.drawImage(image, left, top, width, height, 0, 0, width, height);
          //Resize the image to 224x224
          var resize_canvas = document.createElement('canvas');
          resize_canvas.width = 224;
          resize_canvas.height = 224;
          var resize_ctx = resize_canvas.getContext('2d');
          resize_ctx.drawImage(crop_canvas, 0, 0, 224, 224);
          //Add the image to the list
          images.push(resize_canvas.toDataURL());
        }
        return images;
      }
    }
    
    <!-- Function that takes in an image and returns the split up images -->
    function processPredictions(predictions, image_ids, image_grid) {
      var bboxes = {};
      
      for (var i = 0; i < image_ids.length; i++) {
        predictions[i] = predictionToBbox(predictions[i], image_grid);
        bboxes[image_ids[i]] = nonMaxSuppression(predictions[i], 100);
        
        // back to coco shape
        for (var j = 0; j < bboxes[image_ids[i]].length; j++) {
          bboxes[image_ids[i]][j][2] = bboxes[image_ids[i]][j][2] - bboxes[image_ids[i]][j][0];
          bboxes[image_ids[i]][j][3] = bboxes[image_ids[i]][j][3] - bboxes[image_ids[i]][j][1];
        }
      }
      return bboxes;
    }
    
    <!-- Function that takes in an image and returns the split up images -->
    function predictionToBbox(bboxes, image_grid) {
      bboxes = bboxes.copy();
      
      var im_width = (image_grid[:,:,2] * 32);
      var im_height = (image_grid[:,:,3] * 32);
      
      // descale x,y
      for (var i = 0; i < bboxes.length; i++) {
        bboxes[i][1] = (bboxes[i][1] * image_grid[:,:,2]) + image_grid[:,:,0];
        bboxes[i][2] = (bboxes[i][2] * image_grid[:,:,3]) + image_grid[:,:,1];
        bboxes[i][6] = (bboxes[i][6] * image_grid[:,:,2]) + image_grid[:,:,0];
        bboxes[i][7] = (bboxes[i][7] * image_grid[:,:,3]) + image_grid[:,:,1];
      }
      
      // descale width,height
      for (var i = 0; i < bboxes.length; i++) {
        bboxes[i][3] = bboxes[i][3] * im_width;
        bboxes[i][4] = bboxes[i][4] * im_height;
        bboxes[i][8] = bboxes[i][8] * im_width;
        bboxes[i][9] = bboxes[i][9] * im_height;
      }
      
      // centre x,y to top left x,y
      for (var i = 0; i < bboxes.length; i++) {
        bboxes[i][1] = bboxes[i][1] - (bboxes[i][3] / 2);
        bboxes[i][2] = bboxes[i][2] - (bboxes[i][4] / 2);
        bboxes[i][6] = bboxes[i][6] - (bboxes[i][8] / 2);
        bboxes[i][7] = bboxes[i][7] - (bboxes[i][9] / 2);
      }
      
      // width,heigth to x_max,y_max
      for (var i = 0; i < bboxes.length; i++) {
        bboxes[i][3] = bboxes[i][1] + bboxes[i][3];
        bboxes[i][4] = bboxes[i][2] + bboxes[i][4];
        bboxes[i][8] = bboxes[i][6] + bboxes[i][8];
        bboxes[i][9] = bboxes[i][7] + bboxes[i][9];
      }
      
      return bboxes;
    }
    
    <!-- Function that takes in an image and returns the split up images -->
    function nonMaxSuppression(predictions, top_n) {
      var probabilities = [];
      for (var i = 0; i < predictions.length; i++) {
        probabilities.push(predictions[i][0]);
        probabilities.push(predictions[i][5]);
      }
      
      var first_anchors = [];
      for (var i = 0; i < predictions.length; i++) {
        first_anchors.push(predictions[i][1]);
        first_anchors.push(predictions[i][2]);
        first_anchors.push(predictions[i][3]);
        first_anchors.push(predictions[i][4]);
      }
      first_anchors = tf.tensor(first_anchors, [32*32, 4]);
      
      var second_anchors = [];
      for (var i = 0; i < predictions.length; i++) {
        second_anchors.push(predictions[i][6]);
        second_anchors.push(predictions[i][7]);
        second_anchors.push(predictions[i][8]);
        second_anchors.push(predictions[i][9]);
      }
      second_anchors = tf.tensor(second_anchors, [32*32, 4]);
      
      var bboxes = tf.concat(
        [first_anchors,second_anchors],
        axis=0
      );
      bboxes = switchXY(bboxes);
      bboxes = selectTop(probabilities, bboxes, top_n);
      bboxes = switchXY(bboxes);
      
      return bboxes;
    }
    
    <!-- Function that takes in an image and returns the split up images -->
    function switchXY(bboxes) {
      var x1 = bboxes[:,0].copy();
      var y1 = bboxes[:,1].copy();
      var x2 = bboxes[:,2].copy();
      var y2 = bboxes[:,3].copy();
      bboxes[:,0] = y1;
      bboxes[:,1] = x1;
      bboxes[:,2] = y2;
      bboxes[:,3] = x2;
      
      return bboxes;
    }
    
    <!-- Function that takes in an image and returns the split up images -->
    function selectTop(probabilities, boxes, top_n) {
      var top_indices = tf.image.nonMaxSuppression(
        boxes = boxes, 
        scores = probabilities, 
        maxOutputSize = top_n, 
        iouThreshold = 0.05,
        scoreThreshold = 0.05
      );
      
      return boxes.gather(top_indices);
    }
  </script>

  <!-- Helper functions for handling uploaded user images -->
  <script>
    function readURL(input) {
      if (input.files && input.files[0]) {
        var reader = new FileReader();
        reader.onload = function(e) {
          getSplitImages(e.target.result);
        }
        reader.readAsDataURL(input.files[0]);
      }
    }
  </script>

  <!-- Upload image button -->
  <input type="file" onchange="readURL(this);" />
</body>
</html>
