#Necessary imports
from tensorflow.keras.models import load_model
import numpy as np
import tensorflow as tf
import cv2

def get_mask(y_true):
    anchor_one_mask = tf.where(
        y_true[:,:,:,0] == 0, 
        0.5, 
        5.0
    )
    
    anchor_two_mask = tf.where(
        y_true[:,:,:,5] == 0, 
        0.5, 
        5.0
    )
    
    bboxes_mask = tf.concat(
        [anchor_one_mask,anchor_two_mask],
        axis=0
    )
    
    return bboxes_mask

#@title
def non_max_suppression(predictions, top_n):
    probabilities = np.concatenate((predictions[:,:,0].flatten(), predictions[:,:,5].flatten()), axis=None)
    
    first_anchors = predictions[:,:,1:5].reshape((32*32, 4))
    second_anchors = predictions[:,:,6:10].reshape((32*32, 4))
    bboxes = np.concatenate(
        (first_anchors,second_anchors),
        axis=0
    )
    bboxes = switch_x_y(bboxes)
    bboxes, probabilities = select_top(probabilities, bboxes, top_n=top_n)
    bboxes = switch_x_y(bboxes)
    
    return bboxes

def switch_x_y(bboxes):
    x1 = bboxes[:,0].copy()
    y1 = bboxes[:,1].copy()
    x2 = bboxes[:,2].copy()
    y2 = bboxes[:,3].copy()
    bboxes[:,0] = y1
    bboxes[:,1] = x1
    bboxes[:,2] = y2
    bboxes[:,3] = x2
    
    return bboxes
def select_top(probabilities, boxes, top_n=10):
    top_indices = tf.image.non_max_suppression(
        boxes = boxes, 
        scores = probabilities, 
        max_output_size = top_n, 
        iou_threshold = 0.05,
        score_threshold = 0.05
    )
    top_indices = top_indices.numpy()
    
    return boxes[top_indices], probabilities[top_indices]

def prediction_to_bbox(bboxes, image_grid):    
    bboxes = bboxes.copy()
    
    im_width = (image_grid[:,:,2] * 32)
    im_height = (image_grid[:,:,3] * 32)
    
    # descale x,y
    bboxes[:,:,1] = (bboxes[:,:,1] * image_grid[:,:,2]) + image_grid[:,:,0]
    bboxes[:,:,2] = (bboxes[:,:,2] * image_grid[:,:,3]) + image_grid[:,:,1]
    bboxes[:,:,6] = (bboxes[:,:,6] * image_grid[:,:,2]) + image_grid[:,:,0]
    bboxes[:,:,7] = (bboxes[:,:,7] * image_grid[:,:,3]) + image_grid[:,:,1]
    
    # descale width,height
    bboxes[:,:,3] = bboxes[:,:,3] * im_width 
    bboxes[:,:,4] = bboxes[:,:,4] * im_height
    bboxes[:,:,8] = bboxes[:,:,8] * im_width 
    bboxes[:,:,9] = bboxes[:,:,9] * im_height
    
    # centre x,y to top left x,y
    bboxes[:,:,1] = bboxes[:,:,1] - (bboxes[:,:,3] / 2)
    bboxes[:,:,2] = bboxes[:,:,2] - (bboxes[:,:,4] / 2)
    bboxes[:,:,6] = bboxes[:,:,6] - (bboxes[:,:,8] / 2)
    bboxes[:,:,7] = bboxes[:,:,7] - (bboxes[:,:,9] / 2)
    
    # width,heigth to x_max,y_max
    bboxes[:,:,3] = bboxes[:,:,1] + bboxes[:,:,3]
    bboxes[:,:,4] = bboxes[:,:,2] + bboxes[:,:,4]
    bboxes[:,:,8] = bboxes[:,:,6] + bboxes[:,:,8]
    bboxes[:,:,9] = bboxes[:,:,7] + bboxes[:,:,9]
    
    return bboxes


def process_predictions(predictions, image_ids, image_grid):
    bboxes = {}
    
    for i, image_id in enumerate(image_ids):
        predictions[i] = prediction_to_bbox(predictions[i], image_grid)
        bboxes[image_id] = non_max_suppression(predictions[i], top_n=100)
        
        # back to coco shape
        bboxes[image_id][:,2:4] = bboxes[image_id][:,2:4] - bboxes[image_id][:,0:2]
    
    return bboxes

#This function takes an image and a list of bounding boxes and splits the image into multiple images based on the bounding boxes
def split_image(image_path, bboxes):
    image = cv2.imread(image_path)
    ratio = image.shape[0] / 256
    images = []
    for box in bboxes[image_path]:
      left = max(int((box[0]-8)*ratio),0)
      top = max(int((box[1]-8)*ratio),0)
      width = min(int((box[2]+16)*ratio),image.shape[1])
      height = min(int((box[3]+16)*ratio),image.shape[0])
      #Crop the image
      crop_img = image[top:top+height, left:left+width]
      #Resize the image to 224x224
      crop_img = cv2.resize(crop_img, (224,224))
      #Add the image to the list
      images.append(crop_img)
    return images

#Function that takes in an image and returns the split up images
def get_split_images(image_path):
    #Load the image
    image = cv2.imread(image_path)
    plt.imshow(image)
    #Resize the image to 256x256
    image = cv2.resize(image, (256,256))
    #Convert the image to a numpy array
    image = np.array(image)
    #Reshape the image to fit the model
    image = image.reshape(1,256,256,3)
    #Normalize the image
    image = image/255.0
    #Get the predictions
    predictions = diceFaceModel.predict(image)
    #Process the predictions
    bboxes = process_predictions(predictions, [image_path], image_grid)
    #Split the image
    images = split_image(image_path, bboxes)
    return images
    
diceFaceModel = load_model('/content/drive/MyDrive/ESE360 Dataset/diceDetectionModel',
                           compile=False)

image_grid = np.zeros((32, 32, 4))
  # x, y, width, height
cell = [0, 0, 256 / 32, 256 / 32] 

for i in range(0, 32):
    for j in range(0, 32):
        image_grid[i,j] = cell

        cell[0] = cell[0] + cell[2]

    cell[0] = 0
    cell[1] = cell[1] + cell[3]
    
-------- END PYTHON CODE BLOCK --------

We now want to use this model on a web app using tensorflowjs. We have the model folder in ./diceReaderModeltfjs_reduced/model.json, below is the javascript code that implements get_split_images, including all the helper functions it needs. The file below is a basic html web app that lets the user submit a photo and it displays all the split images from that photo.

-------- START HTML CODE BLOCK --------

<html>
<head>
  <title>TensorflowJS Segmentation Classification</title>
</head>
<body>
  <h1>TensorflowJS ImageSegmentationClassification</h1>

  <!-- Load the TensorflowJS library -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>

  <!-- Load the model from the local folder -->
  <script>
    const modelUrl = './diceDetectionModeltfjs_reduced/model.json';
    let model;

    async function loadModel() {
      model = await tf.loadLayersModel(modelUrl);
    }

    loadModel();
    
    <!-- Function that loads the image and returns the split images -->
    async function getSplitImages(image_path) {
      //Load the image
      var image = new Image();
      image.src = image_path;
      image.onload = function() {
        //Resize the image to 256x256
        var canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        var ctx = canvas.getContext('2d');
        ctx.drawImage(image, 0, 0, 256, 256);
        //Convert the image to a numpy array
        var imageData = ctx.getImageData(0, 0, 256, 256);
        var data = imageData.data;
        var image = [];
        for (var i = 0; i < data.length; i += 4) {
          image.push(data[i]/255.0);
          image.push(data[i+1]/255.0);
          image.push(data[i+2]/255.0);
        }
        //Reshape the image to fit the model
        image = tf.tensor(image, [1,256,256,3]);
        //Get the predictions
        var predictions = model.predict(image);
        //Process the predictions
        var bboxes = processPredictions(predictions, [image_path], image_grid);
        //Split the image
        var images = splitImage(image_path, bboxes);
        //Display the images
        for (var i = 0; i < images.length; i++) {
          var img = document.createElement('img');
          img.src = images[i];
          document.body.appendChild(img);
        }
      }
    }
    
    <!-- Function that takes an image and a list of bounding boxes and splits the image into multiple images based on the bounding boxes -->
    function splitImage(image_path, bboxes) {
      var image = new Image();
      image.src = image_path;
      image.onload = function() {
        var ratio = image.height / 256;
        var images = [];
        for (var i = 0; i < bboxes[image_path].length; i++) {
          var box = bboxes[image_path][i];
          var left = Math.max(Math.round((box[0]-8)*ratio),0);
          var top = Math.max(Math.round((box[1]-8)*ratio),0);
          var width = Math.min(Math.round((box[2]+16)*ratio),image.width);
          var height = Math.min(Math.round((box[3]+16)*ratio),image.height);
          //Crop the image
          var crop_canvas = document.createElement('canvas');
          crop_canvas.width = width;
          crop_canvas.height = height;
          var crop_ctx = crop_canvas.getContext('2d');
          crop_ctx.drawImage(image, left, top, width, height, 0, 0, width, height);
          //Resize the image to 224x224
          var resize_canvas = document.createElement('canvas');
          resize_canvas.width = 224;
          resize_canvas.height = 224;
          var resize_ctx = resize_canvas.getContext('2d');
          resize_ctx.drawImage(crop_canvas, 0, 0, 224, 224);
          //Add the image to the list
          images.push(resize_canvas.toDataURL());
        }
        return images;
      }
    }
    
    <!-- Function that takes in an image and returns the split up images -->
    function processPredictions(predictions, image_ids, image_grid) {
      var bboxes = {};
      
      for (var i = 0; i < image_ids.length; i++) {
        predictions[i] = predictionToBbox(predictions[i], image_grid);
        bboxes[image_ids[i]] = nonMaxSuppression(predictions[i], 100);
        
        // back to coco shape
        for (var j = 0; j < bboxes[image_ids[i]].length; j++) {
          bboxes[image_ids[i]][j][2] = bboxes[image_ids[i]][j][2] - bboxes[image_ids[i]][j][0];
          bboxes[image_ids[i]][j][3] = bboxes[image_ids[i]][j][3] - bboxes[image_ids[i]][j][1];
        }
      }
      return bboxes;
    }
    
    <!-- Function that takes in an image and returns the split up images -->
    function predictionToBbox(bboxes, image_grid) {
      bboxes = bboxes.copy();
      
      var im_width = (image_grid[:,:,2] * 32);
      var im_height = (image_grid[:,:,3] * 32);
      
      // descale x,y
      for (var i = 0; i < bboxes.length; i++) {
        bboxes[i][1] = (bboxes[i][1] * image_grid[:,:,2]) + image_grid[:,:,0];
        bboxes[i][2] = (bboxes[i][2] * image_grid[:,:,3]) + image_grid[:,:,1];
        bboxes[i][6] = (bboxes[i][6] * image_grid[:,:,2]) + image_grid[:,:,0];
        bboxes[i][7] = (bboxes[i][7] * image_grid[:,:,3]) + image_grid[:,:,1];
      }
      
      // descale width,height
      for (var i = 0; i < bboxes.length; i++) {
        bboxes[i][3] = bboxes[i][3] * im_width;
        bboxes[i][4] = bboxes[i][4] * im_height;
        bboxes[i][8] = bboxes[i][8] * im_width;
        bboxes[i][9] = bboxes[i][9] * im_height;
      }
      
      // centre x,y to top left x,y
      for (var i = 0; i < bboxes.length; i++) {
        bboxes[i][1] = bboxes[i][1] - (bboxes[i][3] / 2);
        bboxes[i][2] = bboxes[i][2] - (bboxes[i][4] / 2);
        bboxes[i][6] = bboxes[i][6] - (bboxes[i][8] / 2);
        bboxes[i][7] = bboxes[i][7] - (bboxes[i][9] / 2);
      }
      
      // width,heigth to x_max,y_max
      for (var i = 0; i < bboxes.length; i++) {
        bboxes[i][3] = bboxes[i][1] + bboxes[i][3];
        bboxes[i][4] = bboxes[i][2] + bboxes[i][4];
        bboxes[i][8] = bboxes[i][6] + bboxes[i][8];
        bboxes[i][9] = bboxes[i][7] + bboxes[i][9];
      }
      
      return bboxes;
    }
    
    <!-- Function that takes in an image and returns the split up images -->
    function nonMaxSuppression(predictions, top_n) {
      var probabilities = [];
      for (var i = 0; i < predictions.length; i++) {
        probabilities.push(predictions[i][0]);
        probabilities.push(predictions[i][5]);
      }
      
      var first_anchors = [];
      for (var i = 0; i < predictions.length; i++) {
        first_anchors.push(predictions[i][1]);
        first_anchors.push(predictions[i][2]);
        first_anchors.push(predictions[i][3]);
        first_anchors.push(predictions[i][4]);
      }
      first_anchors = tf.tensor(first_anchors, [32*32, 4]);
      
      var second_anchors = [];
      for (var i = 0; i < predictions.length; i++) {
        second_anchors.push(predictions[i][6]);
        second_anchors.push(predictions[i][7]);
        second_anchors.push(predictions[i][8]);
        second_anchors.push(predictions[i][9]);
      }
      second_anchors = tf.tensor(second_anchors, [32*32, 4]);
      
      var bboxes = tf.concat(
        [first_anchors,second_anchors],
        axis=0
      );
      bboxes = switchXY(bboxes);
      bboxes = selectTop(probabilities, bboxes, top_n);
      bboxes = switchXY(bboxes);
      
      return bboxes;
    }
    
    <!-- Function that takes in an image and returns the split up images -->
    function switchXY(bboxes) {
      var x1 = bboxes[:,0].copy();
      var y1 = bboxes[:,1].copy();
      var x2 = bboxes[:,2].copy();
      var y2 = bboxes[:,3].copy();
      bboxes[:,0] = y1;
      bboxes[:,1] = x1;
      bboxes[:,2] = y2;
      bboxes[:,3] = x2;
      
      return bboxes;
    }
    
    <!-- Function that takes in an image and returns the split up images -->
    function selectTop(probabilities, boxes, top_n) {
      var top_indices = tf.image.nonMaxSuppression(
        boxes = boxes, 
        scores = probabilities, 
        maxOutputSize = top_n, 
        iouThreshold = 0.05,
        scoreThreshold = 0.05
      );
      
      return boxes.gather(top_indices);
    }
  </script>

  <!-- Helper functions for handling uploaded user images -->
  <script>
    function readURL(input) {
      if (input.files && input.files[0]) {
        var reader = new FileReader();
        reader.onload = function(e) {
          getSplitImages(e.target.result);
        }
        reader.readAsDataURL(input.files[0]);
      }
    }
  </script>

  <!-- Upload image button -->
  <input type="file" onchange="readURL(this);" />
</body>
</html>
